[toc]

# Java基础知识

## 1.概述

​		Java不只是一种语言。Java是一个完整的平台，有一个庞大的库，其中包含了许多可重用的代码和一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。

### 1.1Java“白皮书”的关键术语

1. 简单性：Java和C++主要的不同点在于Java用接口代替了C++中的多重继承。

2. 面向对象

3. 分布式

4. 健壮性

5. 安全性

   Java的设计能够防范各种攻击，其中包括：

   - 运行时堆栈溢出。如蠕虫和病毒常用的攻击手段。
   - 破坏自己的进程空间之外的内存。
   - 未经授权读写文件。

6. 体系结构中立

7. 可移植性

8. 解释性：Java解释器可以在任何一支了解释器的机器上执行Java字节码。

9. 高性能：尽管对解释后的字节码性能以及比较满意，但在有些场合下还需要更加高效的性能。字节码可以（在运行时刻）动态地翻译成对应这个应用的特定CPU的机器码。例如，即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即内联）。

10. 多线程：可以带来更好的交互响应和实时行为。

11. 动态性：库中可以自由地添加新方法和实例变量，而对客户端没有任何影响。当需要将某些代码添加到正在运行的程序中时，动态性是一个非常重要的特性。

### 1.2 Java applet和Internet

​       在网页上运行的Java程序称为applet。要使用applet，需要启用Java的Web浏览器执行字节码。不需要安装任何软件，任何时候只要访问包含applet的网页都会得到程序的最新版本。要感谢虚拟机的安全性，让我们不必担心来自恶意代码的攻击。

​       在网页中插入一个applet就如同在网页中嵌入一幅图片，applet会成为页面的一部分，文本环绕着applet所占据的空间周围。

​       实际上，为了在浏览器中的到动态效果，Adobe的Flash技术变得相当流行。

### 1.3 Java发展简史

Java的历史可以追溯到1991年，最初命名为“Oak”，后来更名为“Java”。

1996年年初，Sun发布了Java的第一个版本Java1.1，弥补了Java1.0中很多明显的缺陷。

1998年12月，发布Java1.2，取代了早期玩具式的GUI，其图形工具箱更加精细，具有可伸缩性。更加接近“一次编写，随处运行”。

5.0版是自1.1版以来第一个对Java语言做出重大改进的版本。在这个版本中加入了泛型类型（generic type）（类似于C++的模板），其挑战性在于添加这一特性并没有对虚拟机做出任何修改。还有受C#启发的语言特性：“for each”循环、自动装箱和注解。

2006年年末，版本6发布，没有对语言方面进行改进，但是改进了其他性能，并增强了类库。

2009年，Sun公司被Oracle收购。

2011年Oracle发布Java 7。

2014年，发布Java 8。提供了一种“函数式”编程方式，可以更容易表述并发执行的计算。

2017年9月，发布Java 9。

2018年3月，发布Java 10。

2018年9月，发布Java 11（LTS - Long-Term-Support）。按照 Oracle 的计划，每三年会有一个 LTS 版本。

2019年3月，发布Java 12。

2019年9月，发布Java 13。

![截屏2020-11-05 00.00.47](/Users/ym/Documents/实习/Java/png/截屏2020-11-05 00.00.47.png)

### 1.4 对Java的常见误解

1. Java是HTML的扩展

   Java是一种程序设计语言，HTML是一种描述网页结构的方式。除了用于在网页上放置的Java applet的HTML的扩展之外，二者没有任何共同之处。

2. 使用XML，所有不需要Java

   Java是一种程序设计语言，XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据，Java API对XML处理提供了很好的支持。

3. Java是解释型的，因此对于关键的应用程序速度太慢了

   早期的Java是解释型的，现在的Java虚拟机使用了即时编译器，因此采用Java编写的“热点”代码其运行速度与C++相差无几，有些情况下甚至更快。

## 2. Java程序设计环境

JDK：Java Development Kit（编写Java程序的程序员使用的软件）

JRE：Java Runtime Environment（运行Java程序的用户使用的软件，包含虚拟机但不包含编译器）

Java SE(Java Standard Edition)

Java EE(Java Enterprise Edition)

Java ME(Java Micro Edition)

## 3. Java的基本程序设计结构

### 3.1 一个Java应用程序

**标准的命名规范**：类名是以大写字母开头的名词。如果名字由多个单词组成，每一个单词的第一个字母都应该大写（称为骆驼命名法）。

源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。

编译源代码得到一个包含这个类字节码的文件。Java编译器将字节码文件自动命名为“源文件名.class”，并与源文件存储在同一个目录下。

运行已编译的程序时，Java虚拟机将从指定类中的main方法开始执行。在类的源文件里必须包含一个main方法。

**注**：main方法必须声明为public。当main方法不是public时，有些版本的Java解释器也可以执行Java应用程序。在Java1.4及以后的版本中强制main方法必须是public。

**与C++的区别**：Java中的所有函数都是某个类的方法。因此，Java中的main方法必须有一个外壳（shell）类。Java中的main方法必须是静态的。

### 3.2 注释

单行注释：//

多行注释：/* 注释 */

第3种注释可以自动生成文档：以 /** 开始，以 */ 结束。

**注**：Java中 /* */ 不能嵌套。

### 3.3 数据类型

Java是强类型语言，必须为每一个变量声明一种类型。

Java中有**8种基本类型（primitive type）**，包括4种整型、2种浮点类型、1种字符类型char（用于表示Unicode编码的代码单元）和1种表示真值的boolean类型。

**注**：Java有一个能表示任意精度的算术包，通常称为“大数”（big number）。但它不是基本Java类型，而是一个Java对象。

#### 3.3.1 整型

整型用于表示没有小数部分的数值，允许是负数。

| 类型  | 存储需求 |              取值范围              |
| :---: | :------: | :--------------------------------: |
|  int  |  4字节   | -2<sup>31 </sup>~ 2<sup>31</sup>-1 |
| short |  2字节   | -2<sup>15</sup> ~ 2<sup>15</sup>-1 |
| long  |  8字节   | -2<sup>63</sup> ~ 2<sup>63</sup>-1 |
| byte  |  1字节   |  -2<sup>7</sup> ~ 2<sup>7</sup>-1  |

byte和short类型主要用于特定的应用场合，例如，底层的文件处理或者存储空间很宝贵时的大数组。

Java中，**整型的范围与运行Java代码的机器无关**。解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植的诸多问题。C和C++程序会针对不同的处理器选择最为高效的整型，这样会造成在32位处理器上运行很好的C程序会在16位系统上运行时发生整数溢出。由于Java程序必须保证在所有机器上都能够得到相同的运行结果，所以各种数据类型的取值范围必须固定。

长整型数值有一个后缀L或l（如40000000L），十六进制数值有一个前缀0x或0X（如0xCAFE），八进制有一个前缀0（如010，对应十进制的8）。从Java7开始，加前缀0b或0B就可以写二进制数，如0b1001是9。

**注**：

- **C和C++中，int和long等类型的大小与目标平台相关**。在8086这样的16位处理器上整数占2字节，但在32位处理器（比如Pentium或SPARC）上，整数则为4字节。这些差异，对编写跨平台程序带来了很大的难度。
- **Java中所有的数值类型所占据的字节数与平台无关**。
- **Java没有任何无符号（unsigned）形式的int、long、short或byte类型**。
- 如果要使用不可能为负的整数值而且确实需要额外的一位（bit），也可以把有符号整数值解释为无符号数。例如，一个byte值b可以不代表范围-128到127，表示0到255的范围，也可以存储在一个byte中。基于二进制算术运算的性质，只要不溢出，加法、减法和乘法都能正常计算。但是对于其他运算，需要调用Byte.toUnsignedInt(b)来得到一个0到255的int值，然后处理这个整数值，再把它转换回byte。Integer和Long类都提供了处理无符号除法和求余数的方法。

#### 3.3.2 浮点类型

浮点类型用于表示有小数部分的数值。

|  类型  | 存储需求 |                        取值范围                        |
| :----: | :------: | :----------------------------------------------------: |
| float  |  4字节   |      大约 ± 3.402 823 47E+38F（有效位数为6~7位）       |
| double |  8字节   | 大约 ± 1.797 693 134 862 315 70E+308（有效位数为15位） |

float类型的数值有一个后缀F或f（例如，3.14F），没有后缀F的浮点数值总是默认为double类型。或者后缀加D或d（例如3.14D）。

**可以用十六进制表示浮点数值**。例如，0.125 = 2<sup>-3</sup>可以表示成0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e（e在十六进制中表示十进制的14）。**尾数采用十六进制，指数采用十进制**。**指数的基数是2**，不是10。

所有的浮点数值计算都遵循IEEE 754规范。用于表示溢出和出错情况的三个特殊的浮点数值：

- 正无穷大（如，正整数除0）
- 负无穷大
- NaN（不是一个数字）（如，0/0或者负数的平方根）

常量Double.POSITIVE_INFINITY，Double.NEGATIVE_INFINITY和Double.NaN（以及相应的Float类型的常量）分别表示这三种特殊的值。不能直接检测一个特定值是都等于Double.NaN：

```java
if(x == Double.NaN) // is never true
```

所有“非数值”的值都认为是不相同的。可以通过Double.isNaN方法来判断：

```java
if(Double.isNaN(x)) // check wheither x is "not a number"
```

**注**：浮点数值不适用于无法接受舍入误差的金融计算。例如System.out.println(2.0-1.1)将打印出0.899999999999，而不是期望的0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确表示分数1/10。这就好像十进制无法精确表示分数1/3一样。**如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类**。

#### 3.3.3 char类型

char类型原本用于表示单个字符，但如今有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。

char类型的字面量值要用单引号括起来，如'A'是编码值为65的字符常量，"A"是包含一个字符A的字符串。

char类型的值可以表示为十六进制值，其范围从\u0000到\uFFFF，\u是转义序列。

**注**：Unicode转义序列会在解析代码之前得到处理。

#### 3.3.4 boolean类型

boolean类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行互相转换。

**与C++的区别**：C++中，数值甚至指针可以代替boolean值。值0相当于布尔值false，非0值相当于布尔值true。Java中不是这样。

### 3.4 变量和常量

#### 3.4.1 变量

- 逐一声明每一个变量可以提高程序的可读性。
- 变量的声明尽可能靠近变量第一次使用的地方。
- **声明一个变量后，必须用赋值语句对变量进行显示初始化**。

```java
int vacationDays;
System.out.println(vacationDays); // ERROR -- variable not initialized
```

- 从Java10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无需指定类型：

```java
var vacationDays = 12; // vacationDays is an int
var greeting = "Hello"; // greeting is a String
```

**与C++的区别**：C和C++区分变量的声明和定义。例如，int i = 10; 是一个定义。extern int i; 是一个声明。**Java中不区分变量的声明和定义**。

#### 3.4.2 常量

Java中，使用关键字final指示常量。final表示这个变量只能被赋值一次，一旦被赋值之后，就不能再修改了。

常量名习惯使用全大写。

**类常量**：可以在类中的多个方法中使用，用**static final**设置一个类常量。**类常量的定义位于main方法的外部**。同一个类中的其他方法可以使用；如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。

**与C++的区别**：C++定义常量的两种方法 ①使用#define预处理器 ②使用const关键字。const是Java保留的关键字，但目前并没有使用。Java中必须使用final定义常量。

#### 3.4.3 枚举类型

变量的取值只在一个有限的集合内，针对这种情况，可以自定义枚举类型。枚举类型包括有限个命名的值。

```java
enum Size { SMALL, MEDIUM, LAGER, EXTRA_LAGER };
//声明这种类型的变量
Size s = Size.MEDIUM;
```

Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值。

### 3.5 运算符

#### 3.5.1 算术运算符

- 整数被0除将会产生一个异常，浮点数被0除将会得到无穷大或NaN结果。
- 一个正整数除以0的结果是正无穷大，计算0/0或者负数的平方根结果为NaN。

```java
public static void main(String[] args) {
	System.out.println(2/0); // Exception in thread "main" java.lang.ArithmeticException: / by zero
	System.out.println(2.0/0); // Infinity
	System.out.println(-2.0/0); // -Infinity
	System.out.println(Math.sqrt(-2)); // NaN
	System.out.println(0.0/0); // NaN
	System.out.println(0.0/0.0); //NaN
	System.out.println(0/0.0); //NaN
	System.out.println(0/0); //Exception in thread "main" java.lang.ArithmeticException: / by zero
}
```

#### 3.5.2 数学函数与常量

- 不必在数学方法名和常量名前添加前缀"Math"，只要在源文件的顶部加上：

```java
import static java.lang.Math.*;
```

- 在Math中，为了达到最佳的性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，应该使用StrictMath类。它实现了“可自由分发的数学库”的算法，确保在所有平台上得到相同的结果。
- Math类提供了一些方法使整数有更好的运算安全性。如果一个计算溢出，数学运算符只是悄悄地返回错误的结果而不做任何提醒。如10亿乘以3的计算结果是-1294967296，因为最大的int值刚刚超过20亿。但如果使用Math.multiplyExact(1000000000, 3)，就会生成一个异常。可以捕获这个异常或者让程序终止，而不是直接给出一个错误结果然后继续悄无声息地执行。

#### 3.5.3 数值类型之间的转换

无信息丢失的转换：

- byte -> short -> int -> long
- byte -> short -> int -> double
- char -> int
- float -> double

可能有精度损失的转换：

- int -> float
- long -> float
- long -> double

```java
// 123456789是一个大整数，它所包含的位数比float类型所能表示的位数多
int n = 123456789;
float f = n; // f is 1.23456792E8
```

当用一个二元运算符连接两个值时，先要将两个操作数转换为同一种类型，然后再进行计算。

- 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。
- 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。
- 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。
- 否则，两个操作数都将被转换为int类型。

#### 3.5.4 强制类型转换

强制类型转换会丢失一些信息。

- double类型强转为int时，是通过直接截断小数部分将浮点值转换为整型。
- 将一个数值从一种类型强制转换成另一种类型，且又超出了目标类型的表示范围时，结果就会截断成一个完全不同的值。例如，(byte)300的实际值是44。

**不要在boolean类型与任何数值类型之间进行强制类型转换**，若需要可用条件表达式 `b ? 1 : 0`。（Java中boolean只有true和false，并不是用0和1来区分，是与数值毫不相干的类型）

```java
int x = 1;
x += 3.5; // 合法的，会发生强制类型转换，将x设置为(int)(x + 3.5)
```

#### 3.5.5 关系和boolean运算符

&& 和 || 是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。

& 和 | 不采用“短路”方式来求值，得到计算结果之前两个操作数都需要计算。

### 3.6 字符串

从概念上讲，Java字符串就是Unicode字符序列。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。

- 当把一个字符串和一个非字符串的值进行拼接时，后者会转换成字符串（**任何一个Java对象都可以转换成字符串**）。
- 由于不能修改Java字符串中的单个元素，所以**在Java文档中将String类对象称为是*不可变的（immutable）***，如同数字3永远是数字3一样，字符串"Hello"永远包含字符串H、e、l、l和o的代码单元序列。**你不能修改这些值，但是可以修改字符串变量greeting，让它引用另一个字符串**，这就如同可以让原本存放3的数值变量改成存放4一样。

```java
String greeting = "Hello";
greeting = greeting.subString(0, 3) + "p!"; // 将greeting变量的内容从"Hello"修改为"Help!"
```

- 不可变字符串的优点：**编译器可以让字符串共享**。可以想象将各种字符串存放在公共的存储池中，字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。
- **Question**：如果对greeting做另一个赋值会怎么样？因为原始字符串在堆中分配，会引起内存泄露么？
  - `greeting = "Howdy";` 
  - 不会造成内存泄露。Java有自动垃圾回收机制，如果一个内存块不再使用了，系统最终会将其回收。
  - **内存泄露**：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元，直到程序结束。（内存空间使用完后未回收）
- **与C++的区别**：C++ string对象也会自动地进行内存的分配和回收。内存管理是通过构造器、赋值操作和析构器显示执行的。C++字符串是可修改的，即可以修改字符串中的单个字符。
- 用**equals()**检测两个字符串是否相等，不区分大小写检测用equalsIgnoreCase()。不要用 **==** 运算符检测两个字符串是否相等，这个运算符只能确定两个字符串是否存放在同一个位置上。如果字符串在同一个位置上，它们必然相等。但是完全有可能将内容相同的多个字符串副本放置在不同的位置上。如果虚拟机始终将相同的字符串共享，就可以使用 == 运算符检测是否相等，但实际上只有字符串字面量是共享的，+或subString等操作得到的字符串并不共享。
  - **与C++的区别**：C++的string类重载了 == 运算符以便检测字符串内容的相等性。但Java并没有。
- **空串""**：长度为0的字符串，是一个Java对象，串长度为0，内容为空。
- **null**：表示目前没有任何对象与该变量关联。
- StringBuilder类在Java5中引入，前身是StringBuffer，它的效率稍有些低，但允许采用多线程的方式添加或删除字符。如果所有字符串编辑操作都是在单个线程中执行，则应该使用StringBuilder。

### 3.7 输入与输出

#### 3.7.1 读取输入

首先需要构建一个与标准输入流System.in关联的Scanner对象

```java
Scanner in = new Scanner(System.in);
```

Scanner类定义在java.util包中。

因为输入可见，Scanner类不适用于从控制台读取密码，Java 6中引入Console类来实现这个目的。

读取一个文件：

```java
Scanner in = new Scanner(Path.of("myfile.txt"), StandardCharsets.UTF_8);
// 如果文件名中包含反斜杠符号，在每个反斜杠之前再加一个额外的反斜杠转义
// "C:\\mydirectory\\myfile.txt"
```

写入文件，需要构造一个PrintWriter对象。

```java
PrintWriter out = new PrintWriter("myfile.txt", StandardCharsets.UTF_8);
// 如果文件不存在，创建该文件
```

**注**：如果用一个不存在的文件构造一个Scanner，或者用一个无法创建的文件名构造一个PrintWriter，就会产生异常。

### 3.8 控制流程

- **与C++的区别**：Java中不能再嵌套的两个块中声明同名的变量。C++中可以，内层定义的变量会覆盖外层定义的变量。
- switch语句中的case标签可以是：
  - char、byte、short或int的常量表达式。
  - 枚举常量
  - 从Java7开始，case标签可以是字符串字面量

### 3.9 大数

BigInteger类实现任意精度的整数运算。

BigDecimal实现任意精度的浮点数运算。

使用静态的valueOf方法可以将普通的数值转换为大数：

```java
BigInteger a = BigInteger.valueOf(100);
```

对于更大的数，可以使用一个带字符串参数的构造器：

```java
BigInteger reallyBig = new BigInteger("2356593860449564307658140538403904039478957647832851625361");
```

一些常量：BigInteger.ZERO、BigInteger.ONE和BigInteger.TEN，Java 9之后加入了BigInteger.TWO。

不能使用算术运算符（如：+ 和 * ）处理大数，需要使用大数类中的add和multiply方法。（**Java没有提供运算符重载功能**）

```java
BigInteger c = a.add(b); // c = a + b
BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); // d = c * (b + 2)
```

### 3.10 数组

数组存储相同类型值的序列。

- 一旦创建了数组，就不能再改变它的长度了，但可改变单个的数组元素。
- 如果程序运行中，需要经常扩展数组的大小，就应该使用另一种数据结构——数组列表（array list）。
- Java中，允许有长度为0的数组。`new elementType[0]`或`new elementType[]{}`。长度为0的数组与null并不相同。
- **创建一个数字数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组的元素则初始化为一个特殊值null**，表示这些元素还未存放任何对象。
- for each循环：用来依次处理数组（或者其他元素集合）中的每一个元素，而**不必考虑指定下标值**。

```java
for (int element : a) // 循环a中的每一个元素
  System.out.println(element); // 打印

// 利用Arrays类的toString方法，打印数组中的所有值
System.out.println(Arrays.toString(a)); 
// 返回一个包含数组元素的字符串，这些元素包围在中括号内，并用逗号分隔，如[1,2,3,4,5]
```

- Java中，允许将一个数组变量拷贝到另一个数组变量。这时，**两个变量引用同一个数组**。

```java
int[] smallPrimes = {1,2,3,4,5};
int[] luckyNumber = smallPrimes;
luckyNumber[2] = 12; // now smallPrimes[2] is also 12
```

- 如果希望将一个数组的所有值拷贝到一个新的数组中，就要使用Arrays类的copyOf方法：

```java
int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length); 
```

​		第二个参数是新数组的长度，通常用来增加数组的大小

```java
LuckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length); 
```

​		如果数组元素是数值型，那么额外的元素将被赋值为0；如果数组元素是布尔型，则将赋值为false。如果长度小于原始数组的长度，则只拷贝前面的值。

- **与C++的区别**：Java数组与堆栈上的C++数组有很大的不同，但基本与在堆（heap）上分配的数组指针一样。

```java
int[] a = new int[100]; // Java
```

​		不同于

```C++
int a[100]; // C++
```

​		而等同于

```C++
int* a = new int[100]; // C++
```

​		Java中的 [ ] 运算符被预定义为会完成**越界检查**，而且没有指针运算，即不能通过a+1得到数组中的下一个元素。

- 命令行参数：每个Java应用程序中都有一个带String arg[]参数的main方法。
  - 这个参数表明main方法将接收一个字符串数组，即命令行上指定的参数。

```java
public class Message{
  public static void main(String[] args){
    ...
  }
}
```

​			如果使用以下形式调用这个程序：

```java
java Message -g cruel world
```

​			args数组将包含以下内容：

​				`args[0] : "-g"`

​				`agrs[1] : "cruel"`

​				`args[2] : "world"`

​			**注**：Java应用程序的main方法中，程序名并没有存储在args数组中。`args[0] : "-g"`。

- Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组”。
- For each循环二维数组的每一个元素：

```java
for (double[] row : a)
  for (double value : row)
    do something with value
```

- 使用Arrays类中的deepToString方法打印二维数组：

```java
System.out.println(Arrays.deepToString(a));
输出格式：
[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
```

## 4. 对象和类

### 4.1 面向对象程序设计概述

面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。

#### 4.1.1 类

- 类（class）是构造对象的模板或蓝图。
- 由类构造（construct）对象的过程称为创建类的实例（instance）。
- **封装**（encapsulation，有时称为*数据隐藏*）
  - 形式上，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。实现封装的关键在于，**绝对不能让类中的方法直接访问其他类的实例字段。程序只能通过对象的方法与对象数据进行交互。**封装给对象赋予了“黑盒”特征，这是提高重用性和可靠性的关键。这意味着一个类可以完全改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道也不用关心这个类所发生的变化。

- **可以通过扩展其他类来构建新类**。Java中所有的类都扩展自这个Object类。在扩展一个已有的类时，这个扩展后的新类具有被扩展的类的全部属性和方法。通过扩展一个类来建立另外一个类的过程为继承（inheritance）。

#### 4.1.2 对象

对象的三个主要特性：

- 对象的行为（behavior）——可以对对象完成哪些操作，或者可以对对象应用哪些方法？
- 对象的状态（state）——当调用那些方法时，对象会如何响应？
- 对象的标识（identity）——如何区分具有相同行为与状态的不同对象？

对象的行为是用可调用的方法来定义的。

每个对象都保存着描述当前状况的信息，这就是对象的状态。对象状态的改变必须通过调用方法实现（如果不经过方法调用就可以改变对象的状态，只能说明破坏了封装性）。

每个对象都有一个唯一的标识（identity，或称身份）。作为同一个类的实例，每个对象的表示总是不同的，状态也往往存在差异。

#### 4.1.3 类之间的关系

常见的关系有：

- 依赖（“uses-a”）——一个类的方法使用或操纵另一个类的对象。应该尽可能地将互相依赖的类减至最少（尽可能减少类之间的耦合）。
- 聚合（“has-a”）——类A的对象包含类B的对象。
- 继承（“is-a”）——类A扩展类B，类A不但包含从类B继承的方法，还有一些额外的功能。

### 4.2 使用预定义类

Java中要使用**构造器**（constructor，或称为构造函数）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。构造器的名字应该与类名相同。

**对象变量并没有实际包含一个对象，它只是引用一个对象。**

**Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。new操作符的返回值也是一个引用。**

```java
Date deadline = new Date();
```

这个语句包含两部分。表达式`new Date()`构造了一个Date类型的对象，它的值是对新创建对象的一个引用。这个引用存储在变量deadline中。



​		

