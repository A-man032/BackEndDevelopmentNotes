[toc]

# Java基础知识

## 1.概述

​		Java不只是一种语言。Java是一个完整的平台，有一个庞大的库，其中包含了许多可重用的代码和一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。

### 1.1Java“白皮书”的关键术语

1. 简单性：Java和C++主要的不同点在于Java用接口代替了C++中的多重继承。

2. 面向对象

3. 分布式

4. 健壮性

5. 安全性

   Java的设计能够防范各种攻击，其中包括：

   - 运行时堆栈溢出。如蠕虫和病毒常用的攻击手段。
   - 破坏自己的进程空间之外的内存。
   - 未经授权读写文件。

6. 体系结构中立

7. 可移植性

8. 解释性：Java解释器可以在任何一支了解释器的机器上执行Java字节码。

9. 高性能：尽管对解释后的字节码性能以及比较满意，但在有些场合下还需要更加高效的性能。字节码可以（在运行时刻）动态地翻译成对应这个应用的特定CPU的机器码。例如，即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即内联）。

10. 多线程：可以带来更好的交互响应和实时行为。

11. 动态性：库中可以自由地添加新方法和实例变量，而对客户端没有任何影响。当需要将某些代码添加到正在运行的程序中时，动态性是一个非常重要的特性。

### 1.2 Java applet和Internet

​       在网页上运行的Java程序称为applet。要使用applet，需要启用Java的Web浏览器执行字节码。不需要安装任何软件，任何时候只要访问包含applet的网页都会得到程序的最新版本。要感谢虚拟机的安全性，让我们不必担心来自恶意代码的攻击。

​       在网页中插入一个applet就如同在网页中嵌入一幅图片，applet会成为页面的一部分，文本环绕着applet所占据的空间周围。

​       实际上，为了在浏览器中的到动态效果，Adobe的Flash技术变得相当流行。

### 1.3 Java发展简史

Java的历史可以追溯到1991年，最初命名为“Oak”，后来更名为“Java”。

1996年年初，Sun发布了Java的第一个版本Java1.1，弥补了Java1.0中很多明显的缺陷。

1998年12月，发布Java1.2，取代了早期玩具式的GUI，其图形工具箱更加精细，具有可伸缩性。更加接近“一次编写，随处运行”。

5.0版是自1.1版以来第一个对Java语言做出重大改进的版本。在这个版本中加入了泛型类型（generic type）（类似于C++的模板），其挑战性在于添加这一特性并没有对虚拟机做出任何修改。还有受C#启发的语言特性：“for each”循环、自动装箱和注解。

2006年年末，版本6发布，没有对语言方面进行改进，但是改进了其他性能，并增强了类库。

2009年，Sun公司被Oracle收购。

2011年Oracle发布Java 7。

2014年，发布Java 8。提供了一种“函数式”编程方式，可以更容易表述并发执行的计算。

2017年9月，发布Java 9。

2018年3月，发布Java 10。

2018年9月，发布Java 11（LTS - Long-Term-Support）。按照 Oracle 的计划，每三年会有一个 LTS 版本。

2019年3月，发布Java 12。

2019年9月，发布Java 13。

![Java语言的发展状况](https://github.com/A-man032/BackEndDevelopmentNotes/blob/main/Java/png/%E6%88%AA%E5%B1%8F2020-11-05%2000.00.47.png)

### 1.4 对Java的常见误解

1. Java是HTML的扩展

   Java是一种程序设计语言，HTML是一种描述网页结构的方式。除了用于在网页上放置的Java applet的HTML的扩展之外，二者没有任何共同之处。

2. 使用XML，所有不需要Java

   Java是一种程序设计语言，XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据，Java API对XML处理提供了很好的支持。

3. Java是解释型的，因此对于关键的应用程序速度太慢了

   早期的Java是解释型的，现在的Java虚拟机使用了即时编译器，因此采用Java编写的“热点”代码其运行速度与C++相差无几，有些情况下甚至更快。

## 2. Java程序设计环境

JDK：Java Development Kit（编写Java程序的程序员使用的软件）

JRE：Java Runtime Environment（运行Java程序的用户使用的软件，包含虚拟机但不包含编译器）

Java SE(Java Standard Edition)

Java EE(Java Enterprise Edition)

Java ME(Java Micro Edition)

## 3. Java的基本程序设计结构

### 3.1 一个Java应用程序

**标准的命名规范**：类名是以大写字母开头的名词。如果名字由多个单词组成，每一个单词的第一个字母都应该大写（称为骆驼命名法）。

源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。

编译源代码得到一个包含这个类字节码的文件。Java编译器将字节码文件自动命名为“源文件名.class”，并与源文件存储在同一个目录下。

运行已编译的程序时，Java虚拟机将从指定类中的main方法开始执行。在类的源文件里必须包含一个main方法。

**注**：main方法必须声明为public。当main方法不是public时，有些版本的Java解释器也可以执行Java应用程序。在Java1.4及以后的版本中强制main方法必须是public。

**与C++的区别**：Java中的所有函数都是某个类的方法。因此，Java中的main方法必须有一个外壳（shell）类。Java中的main方法必须是静态的。

### 3.2 注释

单行注释：//

多行注释：/* 注释 */

第3种注释可以自动生成文档：以 /** 开始，以 */ 结束。

**注**：Java中 /* */ 不能嵌套。

### 3.3 数据类型

Java是强类型语言，必须为每一个变量声明一种类型。

Java中有**8种基本类型（primitive type）**，包括4种整型、2种浮点类型、1种字符类型char（用于表示Unicode编码的代码单元）和1种表示真值的boolean类型。

**注**：Java有一个能表示任意精度的算术包，通常称为“大数”（big number）。但它不是基本Java类型，而是一个Java对象。

#### 3.3.1 整型

整型用于表示没有小数部分的数值，允许是负数。

| 类型  | 存储需求 |              取值范围              |
| :---: | :------: | :--------------------------------: |
|  int  |  4字节   | -2<sup>31 </sup>~ 2<sup>31</sup>-1 |
| short |  2字节   | -2<sup>15</sup> ~ 2<sup>15</sup>-1 |
| long  |  8字节   | -2<sup>63</sup> ~ 2<sup>63</sup>-1 |
| byte  |  1字节   |  -2<sup>7</sup> ~ 2<sup>7</sup>-1  |

byte和short类型主要用于特定的应用场合，例如，底层的文件处理或者存储空间很宝贵时的大数组。

Java中，**整型的范围与运行Java代码的机器无关**。解决了软件从一个平台移植到另一个平台，或者在同一个平台中的不同操作系统之间进行移植的诸多问题。C和C++程序会针对不同的处理器选择最为高效的整型，这样会造成在32位处理器上运行很好的C程序会在16位系统上运行时发生整数溢出。由于Java程序必须保证在所有机器上都能够得到相同的运行结果，所以各种数据类型的取值范围必须固定。

长整型数值有一个后缀L或l（如40000000L），十六进制数值有一个前缀0x或0X（如0xCAFE），八进制有一个前缀0（如010，对应十进制的8）。从Java7开始，加前缀0b或0B就可以写二进制数，如0b1001是9。

**注**：

- **C和C++中，int和long等类型的大小与目标平台相关**。在8086这样的16位处理器上整数占2字节，但在32位处理器（比如Pentium或SPARC）上，整数则为4字节。这些差异，对编写跨平台程序带来了很大的难度。
- **Java中所有的数值类型所占据的字节数与平台无关**。
- **Java没有任何无符号（unsigned）形式的int、long、short或byte类型**。
- 如果要使用不可能为负的整数值而且确实需要额外的一位（bit），也可以把有符号整数值解释为无符号数。例如，一个byte值b可以不代表范围-128到127，表示0到255的范围，也可以存储在一个byte中。基于二进制算术运算的性质，只要不溢出，加法、减法和乘法都能正常计算。但是对于其他运算，需要调用Byte.toUnsignedInt(b)来得到一个0到255的int值，然后处理这个整数值，再把它转换回byte。Integer和Long类都提供了处理无符号除法和求余数的方法。

#### 3.3.2 浮点类型

浮点类型用于表示有小数部分的数值。

|  类型  | 存储需求 |                        取值范围                        |
| :----: | :------: | :----------------------------------------------------: |
| float  |  4字节   |      大约 ± 3.402 823 47E+38F（有效位数为6~7位）       |
| double |  8字节   | 大约 ± 1.797 693 134 862 315 70E+308（有效位数为15位） |

float类型的数值有一个后缀F或f（例如，3.14F），没有后缀F的浮点数值总是默认为double类型。或者后缀加D或d（例如3.14D）。

**可以用十六进制表示浮点数值**。例如，0.125 = 2<sup>-3</sup>可以表示成0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e（e在十六进制中表示十进制的14）。**尾数采用十六进制，指数采用十进制**。**指数的基数是2**，不是10。

所有的浮点数值计算都遵循IEEE 754规范。用于表示溢出和出错情况的三个特殊的浮点数值：

- 正无穷大（如，正整数除0）
- 负无穷大
- NaN（不是一个数字）（如，0/0或者负数的平方根）

常量Double.POSITIVE_INFINITY，Double.NEGATIVE_INFINITY和Double.NaN（以及相应的Float类型的常量）分别表示这三种特殊的值。不能直接检测一个特定值是都等于Double.NaN：

```java
if(x == Double.NaN) // is never true
```

所有“非数值”的值都认为是不相同的。可以通过Double.isNaN方法来判断：

```java
if(Double.isNaN(x)) // check wheither x is "not a number"
```

**注**：浮点数值不适用于无法接受舍入误差的金融计算。例如System.out.println(2.0-1.1)将打印出0.899999999999，而不是期望的0.9。这种舍入误差的主要原因是浮点数值采用二进制系统表示，而在二进制系统中无法精确表示分数1/10。这就好像十进制无法精确表示分数1/3一样。**如果在数值计算中不允许有任何舍入误差，就应该使用BigDecimal类**。

#### 3.3.3 char类型

char类型原本用于表示单个字符，但如今有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。

char类型的字面量值要用单引号括起来，如'A'是编码值为65的字符常量，"A"是包含一个字符A的字符串。

char类型的值可以表示为十六进制值，其范围从\u0000到\uFFFF，\u是转义序列。

**注**：Unicode转义序列会在解析代码之前得到处理。

#### 3.3.4 boolean类型

boolean类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行互相转换。

**与C++的区别**：C++中，数值甚至指针可以代替boolean值。值0相当于布尔值false，非0值相当于布尔值true。Java中不是这样。

### 3.4 变量和常量

#### 3.4.1 变量

- 逐一声明每一个变量可以提高程序的可读性。
- 变量的声明尽可能靠近变量第一次使用的地方。
- **声明一个变量后，必须用赋值语句对变量进行显示初始化**。

```java
int vacationDays;
System.out.println(vacationDays); // ERROR -- variable not initialized
```

- 从Java10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字var而无需指定类型：

```java
var vacationDays = 12; // vacationDays is an int
var greeting = "Hello"; // greeting is a String
```

**与C++的区别**：C和C++区分变量的声明和定义。例如，int i = 10; 是一个定义。extern int i; 是一个声明。**Java中不区分变量的声明和定义**。

#### 3.4.2 常量

Java中，使用关键字final指示常量。final表示这个变量只能被赋值一次，一旦被赋值之后，就不能再修改了。

常量名习惯使用全大写。

**类常量**：可以在类中的多个方法中使用，用**static final**设置一个类常量。**类常量的定义位于main方法的外部**。同一个类中的其他方法可以使用；如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。

**与C++的区别**：C++定义常量的两种方法 ①使用#define预处理器 ②使用const关键字。const是Java保留的关键字，但目前并没有使用。Java中必须使用final定义常量。

#### 3.4.3 枚举类型

变量的取值只在一个有限的集合内，针对这种情况，可以自定义枚举类型。枚举类型包括有限个命名的值。

```java
enum Size { SMALL, MEDIUM, LAGER, EXTRA_LAGER };
//声明这种类型的变量
Size s = Size.MEDIUM;
```

Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值。

### 3.5 运算符

#### 3.5.1 算术运算符

- 整数被0除将会产生一个异常，浮点数被0除将会得到无穷大或NaN结果。
- 一个正整数除以0的结果是正无穷大，计算0/0或者负数的平方根结果为NaN。

```java
public static void main(String[] args) {
	System.out.println(2/0); // Exception in thread "main" java.lang.ArithmeticException: / by zero
	System.out.println(2.0/0); // Infinity
	System.out.println(-2.0/0); // -Infinity
	System.out.println(Math.sqrt(-2)); // NaN
	System.out.println(0.0/0); // NaN
	System.out.println(0.0/0.0); //NaN
	System.out.println(0/0.0); //NaN
	System.out.println(0/0); //Exception in thread "main" java.lang.ArithmeticException: / by zero
}
```

#### 3.5.2 数学函数与常量

- 不必在数学方法名和常量名前添加前缀"Math"，只要在源文件的顶部加上：

```java
import static java.lang.Math.*;
```

- 在Math中，为了达到最佳的性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，应该使用StrictMath类。它实现了“可自由分发的数学库”的算法，确保在所有平台上得到相同的结果。
- Math类提供了一些方法使整数有更好的运算安全性。如果一个计算溢出，数学运算符只是悄悄地返回错误的结果而不做任何提醒。如10亿乘以3的计算结果是-1294967296，因为最大的int值刚刚超过20亿。但如果使用Math.multiplyExact(1000000000, 3)，就会生成一个异常。可以捕获这个异常或者让程序终止，而不是直接给出一个错误结果然后继续悄无声息地执行。

#### 3.5.3 数值类型之间的转换

无信息丢失的转换：

- byte -> short -> int -> long
- byte -> short -> int -> double
- char -> int
- float -> double

可能有精度损失的转换：

- int -> float
- long -> float
- long -> double

```java
// 123456789是一个大整数，它所包含的位数比float类型所能表示的位数多
int n = 123456789;
float f = n; // f is 1.23456792E8
```

当用一个二元运算符连接两个值时，先要将两个操作数转换为同一种类型，然后再进行计算。

- 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。
- 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。
- 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。
- 否则，两个操作数都将被转换为int类型。

#### 3.5.4 强制类型转换

强制类型转换会丢失一些信息。

- double类型强转为int时，是通过直接截断小数部分将浮点值转换为整型。
- 将一个数值从一种类型强制转换成另一种类型，且又超出了目标类型的表示范围时，结果就会截断成一个完全不同的值。例如，(byte)300的实际值是44。

**不要在boolean类型与任何数值类型之间进行强制类型转换**，若需要可用条件表达式 `b ? 1 : 0`。（Java中boolean只有true和false，并不是用0和1来区分，是与数值毫不相干的类型）

```java
int x = 1;
x += 3.5; // 合法的，会发生强制类型转换，将x设置为(int)(x + 3.5)
```

#### 3.5.5 关系和boolean运算符

&& 和 || 是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。

& 和 | 不采用“短路”方式来求值，得到计算结果之前两个操作数都需要计算。

### 3.6 字符串

从概念上讲，Java字符串就是Unicode字符序列。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，很自然地叫做String。

- 当把一个字符串和一个非字符串的值进行拼接时，后者会转换成字符串（**任何一个Java对象都可以转换成字符串**）。
- 由于不能修改Java字符串中的单个元素，所以**在Java文档中将String类对象称为是*不可变的（immutable）***，如同数字3永远是数字3一样，字符串"Hello"永远包含字符串H、e、l、l和o的代码单元序列。**你不能修改这些值，但是可以修改字符串变量greeting，让它引用另一个字符串**，这就如同可以让原本存放3的数值变量改成存放4一样。

```java
String greeting = "Hello";
greeting = greeting.subString(0, 3) + "p!"; // 将greeting变量的内容从"Hello"修改为"Help!"
```

- 不可变字符串的优点：**编译器可以让字符串共享**。可以想象将各种字符串存放在公共的存储池中，字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。
- **Question**：如果对greeting做另一个赋值会怎么样？因为原始字符串在堆中分配，会引起内存泄露么？
  - `greeting = "Howdy";` 
  - 不会造成内存泄露。Java有自动垃圾回收机制，如果一个内存块不再使用了，系统最终会将其回收。
  - **内存泄露**：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元，直到程序结束。（内存空间使用完后未回收）
- **与C++的区别**：C++ string对象也会自动地进行内存的分配和回收。内存管理是通过构造器、赋值操作和析构器显示执行的。C++字符串是可修改的，即可以修改字符串中的单个字符。
- 用**equals()**检测两个字符串是否相等，不区分大小写检测用equalsIgnoreCase()。不要用 **==** 运算符检测两个字符串是否相等，这个运算符只能确定两个字符串是否存放在同一个位置上。如果字符串在同一个位置上，它们必然相等。但是完全有可能将内容相同的多个字符串副本放置在不同的位置上。如果虚拟机始终将相同的字符串共享，就可以使用 == 运算符检测是否相等，但实际上只有字符串字面量是共享的，+或subString等操作得到的字符串并不共享。
  - **与C++的区别**：C++的string类重载了 == 运算符以便检测字符串内容的相等性。但Java并没有。
- **空串""**：长度为0的字符串，是一个Java对象，串长度为0，内容为空。
- **null**：表示目前没有任何对象与该变量关联。
- StringBuilder类在Java5中引入，前身是StringBuffer，它的效率稍有些低，但允许采用多线程的方式添加或删除字符。如果所有字符串编辑操作都是在单个线程中执行，则应该使用StringBuilder。

### 3.7 输入与输出

#### 3.7.1 读取输入

首先需要构建一个与标准输入流System.in关联的Scanner对象

```java
Scanner in = new Scanner(System.in);
```

Scanner类定义在java.util包中。

因为输入可见，Scanner类不适用于从控制台读取密码，Java 6中引入Console类来实现这个目的。

读取一个文件：

```java
Scanner in = new Scanner(Path.of("myfile.txt"), StandardCharsets.UTF_8);
// 如果文件名中包含反斜杠符号，在每个反斜杠之前再加一个额外的反斜杠转义
// "C:\\mydirectory\\myfile.txt"
```

写入文件，需要构造一个PrintWriter对象。

```java
PrintWriter out = new PrintWriter("myfile.txt", StandardCharsets.UTF_8);
// 如果文件不存在，创建该文件
```

**注**：如果用一个不存在的文件构造一个Scanner，或者用一个无法创建的文件名构造一个PrintWriter，就会产生异常。

### 3.8 控制流程

> **与C++的区别**：Java中不能再嵌套的两个块中声明同名的变量。C++中可以，内层定义的变量会覆盖外层定义的变量。

- switch语句中的case标签可以是：
  - char、byte、short或int的常量表达式。
  - 枚举常量
  - 从Java7开始，case标签可以是字符串字面量

### 3.9 大数

BigInteger类实现任意精度的整数运算。

BigDecimal实现任意精度的浮点数运算。

使用静态的valueOf方法可以将普通的数值转换为大数：

```java
BigInteger a = BigInteger.valueOf(100);
```

对于更大的数，可以使用一个带字符串参数的构造器：

```java
BigInteger reallyBig = new BigInteger("2356593860449564307658140538403904039478957647832851625361");
```

一些常量：BigInteger.ZERO、BigInteger.ONE和BigInteger.TEN，Java 9之后加入了BigInteger.TWO。

不能使用算术运算符（如：+ 和 * ）处理大数，需要使用大数类中的add和multiply方法。（**Java没有提供运算符重载功能**）

```java
BigInteger c = a.add(b); // c = a + b
BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); // d = c * (b + 2)
```

### 3.10 数组

数组存储相同类型值的序列。

- 一旦创建了数组，就不能再改变它的长度了，但可改变单个的数组元素。
- 如果程序运行中，需要经常扩展数组的大小，就应该使用另一种数据结构——数组列表（array list）。
- Java中，允许有长度为0的数组。`new elementType[0]`或`new elementType[]{}`。长度为0的数组与null并不相同。
- **创建一个数字数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组的元素则初始化为一个特殊值null**，表示这些元素还未存放任何对象。
- for each循环：用来依次处理数组（或者其他元素集合）中的每一个元素，而**不必考虑指定下标值**。

```java
for (int element : a) // 循环a中的每一个元素
  System.out.println(element); // 打印

// 利用Arrays类的toString方法，打印数组中的所有值
System.out.println(Arrays.toString(a)); 
// 返回一个包含数组元素的字符串，这些元素包围在中括号内，并用逗号分隔，如[1,2,3,4,5]
```

- Java中，允许将一个数组变量拷贝到另一个数组变量。这时，**两个变量引用同一个数组**。

```java
int[] smallPrimes = {1,2,3,4,5};
int[] luckyNumber = smallPrimes;
luckyNumber[2] = 12; // now smallPrimes[2] is also 12
```

- 如果希望将一个数组的所有值拷贝到一个新的数组中，就要使用Arrays类的copyOf方法：

```java
int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length); 
```

​		第二个参数是新数组的长度，通常用来增加数组的大小

```java
LuckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length); 
```

​		如果数组元素是数值型，那么额外的元素将被赋值为0；如果数组元素是布尔型，则将赋值为false。如果长度小于原始数组的长度，则只拷贝前面的值。

> **与C++的区别**：Java数组与堆栈上的C++数组有很大的不同，但基本与在堆（heap）上分配的数组指针一样。

```java
int[] a = new int[100]; // Java
```

​		不同于

```C++
int a[100]; // C++
```

​		而等同于

```C++
int* a = new int[100]; // C++
```

​		Java中的 [ ] 运算符被预定义为会完成**越界检查**，而且没有指针运算，即不能通过a+1得到数组中的下一个元素。

- 命令行参数：每个Java应用程序中都有一个带String arg[]参数的main方法。
  - 这个参数表明main方法将接收一个字符串数组，即命令行上指定的参数。

```java
public class Message{
  public static void main(String[] args){
    ...
  }
}
```

​			如果使用以下形式调用这个程序：

```java
java Message -g cruel world
```

​			args数组将包含以下内容：

​				`args[0] : "-g"`

​				`agrs[1] : "cruel"`

​				`args[2] : "world"`

​			**注**：Java应用程序的main方法中，程序名并没有存储在args数组中。`args[0] : "-g"`。

- Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组”。
- For each循环二维数组的每一个元素：

```java
for (double[] row : a)
  for (double value : row)
    do something with value
```

- 使用Arrays类中的deepToString方法打印二维数组：

```java
System.out.println(Arrays.deepToString(a));
输出格式：
[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
```

## 4. 对象和类

### 4.1 面向对象程序设计概述

面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。

#### 4.1.1 类

- 类（class）是构造对象的模板或蓝图。
- 由类构造（construct）对象的过程称为创建类的实例（instance）。
- **封装**（encapsulation，有时称为*数据隐藏*）
  - 形式上，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。实现封装的关键在于，**绝对不能让类中的方法直接访问其他类的实例字段。程序只能通过对象的方法与对象数据进行交互。**封装给对象赋予了“黑盒”特征，这是提高重用性和可靠性的关键。这意味着一个类可以完全改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道也不用关心这个类所发生的变化。

- **可以通过扩展其他类来构建新类**。Java中所有的类都扩展自这个Object类。在扩展一个已有的类时，这个扩展后的新类具有被扩展的类的全部属性和方法。通过扩展一个类来建立另外一个类的过程为继承（inheritance）。

#### 4.1.2 对象

对象的三个主要特性：

- 对象的行为（behavior）——可以对对象完成哪些操作，或者可以对对象应用哪些方法？
- 对象的状态（state）——当调用那些方法时，对象会如何响应？
- 对象的标识（identity）——如何区分具有相同行为与状态的不同对象？

对象的行为是用可调用的方法来定义的。

每个对象都保存着描述当前状况的信息，这就是对象的状态。对象状态的改变必须通过调用方法实现（如果不经过方法调用就可以改变对象的状态，只能说明破坏了封装性）。

每个对象都有一个唯一的标识（identity，或称身份）。作为同一个类的实例，每个对象的表示总是不同的，状态也往往存在差异。

#### 4.1.3 类之间的关系

常见的关系有：

- 依赖（“uses-a”）——一个类的方法使用或操纵另一个类的对象。应该尽可能地将互相依赖的类减至最少（尽可能减少类之间的耦合）。
- 聚合（“has-a”）——类A的对象包含类B的对象。
- 继承（“is-a”）——类A扩展类B，类A不但包含从类B继承的方法，还有一些额外的功能。

### 4.2 使用预定义类

Java中要使用**构造器**（constructor，或称为构造函数）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。构造器的名字应该与类名相同。

**对象变量并没有实际包含一个对象，它只是引用一个对象。**

**Java中，任何对象变量的值都是对存储在另外一个地方的某个对象的引用。new操作符的返回值也是一个引用。**

```java
Date deadline = new Date();
```

这个语句包含两部分。表达式`new Date()`构造了一个Date类型的对象，它的值是对新创建对象的一个引用。这个引用存储在变量deadline中。

可以显示地将对象变量设置为null，指示这个对象变量目前没有引用任何对象。

> **与C++的区别**：
>
> Java中的对象变量不等价于C++中的引用。在C++中没有null引用，而且引用不能赋值。可以把Java中的对象变量看作类似于C++的**对象指针**。例如，
>
> ```java
> Date birthday; // Java
> ```
>
> 等价于
>
> ```java
> Date* birthday; // C++
> ```
>
> Date* 指针只有使用new调用才会初始化。就这一点而言，C++和Java的语法几乎是一样的。
>
> ```java
> Date* birthday = new Date(); // C++
> ```
>
> 如果把一个变量复制到另一个变量，两个变量就指向同一个日期，即它们是同一个对象的指针。Java中的null引用对应于C++中的NULL指针。

​		

**所有的Java对象都存储在堆中。**当一个对象包含另一个对象变量时，它只是包含着另一个堆对象的指针。

**Java类库中的LocalDate类**：

​		类库设计者决定将保存时间与给时间点命名分开。所以标准Java类库分别包含了两个类：表示时间点的Date类和表示日期的LocalDate类。

​		不要使用构造器来构造LocalDate类的对象，应当使用静态**工厂方法**（factory method），它会代表你调用构造器。

```java
LocalDate.now(); // 构造一个新对象，表示构造这个对象时的日期
LocalDate.of(1999, 12, 31); // 提供年月日来构造对应一个特定日期的对象
LocalDate newYearsEve = LocalDate.of(1999, 12, 31); // 将构造的对象保存在一个对象变量中

// 获得LocalDate对象的年月日
int year = newYearsEve.getYear(); // 1999
int month = newYearsEve.getMonthValue(); // 12
int day = newYearsEve.getDayOfMonth(); // 31

// 获得一个据当前对象指定天数的一个新日期
LocalDate aThousandDaysLater = newYearsEve.plusDays(1000); 
year = aThousandDaysLater.getYear(); // 2002
month = aThousandDaysLater.getMonthValue(); // 09
day = aThousandDaysLater.getDayOfMonth(); // 26
```

​		LocalDate类封装了实例字段来维护所设置的日期。封装的意义就在于内部表示不重要，重要的是类对外提供的方法。

​		plusDays方法会生成一个新的LocalDate对象，原来调用这个方法的对象不做任何改动。

- 更改器方法（mutator method）：访问对象且修改对象的方法。
- 访问器方法（accessor method）：只访问对象而不修改对象的方法。

> **与C++的区别**：C++中，带有const后缀的方法是访问器方法；没有声明为const的方法默认为更改器方法。Java中，访问器方法和更改器方法在语法上没有明显的区别。

### 4.3 用户自定义的类

- **将实例字段标记为private**

**构造器**：

- 构造器总是结合new来调用，不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的。
- 构造器与类同名
- 每个类可以有一个以上的构造器
- 构造器可以有0个、1个或多个参数
- 构造器没有返回值

**所有的Java对象都是在堆中构造的，构造器总是结合new操作符一起使用。不要在构造器中定义与实例字段同名的局部变量（这些变量只能在构造器内部访问，会遮蔽同名的实例）。**

**隐式参数和显示参数**：

- 隐式参数：出现在方法名前的对象（方法调用的接收者），**this关键之指示隐式参数**。
- 显示参数：方法的形参

> **与C++的区别**：C++中通常在类的外卖定义方法，如果在类的内部定义方法，这个方法自动成为内联方法。Java中，所有的方法都必须在类的内部定义，但并不代表他们是内联方法。**是否将某个方法设置为内联方法是Java虚拟机的任务**。

**final关键字**：

- final修饰基本类型，起到常量作用，基本类型的值不可变
- final修饰引用类型，不能再指向其他对象，但被引用的对象值可以改变

### 4.4 方法参数

- Java程序设计语言总是采用**按值调用**（方法得到的是所有参数值的一个副本，具体来说，方法不能修改传递给它的任何参数变量的内容）
  - 方法不能修改基本数据类型（数字、布尔值）的参数。
  - 参数是对象引用时，方法就可以改变对象参数状态。理由：方法得到的是对象引用的副本，原来的对象引用和这个副本都引用同一个对象。**对象引用是按值传递的。**

**总结Java中对 方法参数 能做什么和不能做什么：**

- 方法不能修改基本数据类型的参数（即数值型或布尔型）
- 方法可以改变对象参数的状态
- 方法不能让一个对象参数引用一个新的对象

> **与C++的区别**：C++中有按值调用和按引用调用，引用参数标有&符合。Java中总是按值调用。

### 4.6 对象构造

#### 4.6.1 重载

多个方法有**相同的名字，不同的参数**，就出现了重载。编译器用各个方法首部中的参数类型与特定方法调用中所使用的值类型进行匹配，来选择正确的方法。编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好（查找匹配的过程被称为是重载解析）。

Java允许重载任何方法，而不只是构造器方法。完整地描述一个方法，需要指定方法名以及参数类型，这叫方法的签名。

**返回类型不是方法签名的一部分。也就是不能有两个名字相同、参数类型也相同却有不同返回类型的方法。**

#### 4.6.2 默认字段初始化

如果在构造器中没有显示地为字段设置初值，那么就会被自动地赋予默认值：数值为0、布尔值为false、对象引用为null。

> **字段和局部变量的区别：**方法中的局部变量必须明确地初始化。但是在类中，如果没有初始化类中的字段，将会自动初始化为默认值（0、false、null）。

#### 4.6.3 无参数的构造器

**如果一个类没有编写构造器，就会为你提供一个无参数构造器。**这个构造器将所有的实例字段设置为默认值。

如果一个类提供了至少一个构造器，但是没有提供无参数的构造器，那么构造对象时不提供参数就是不合法的。

> **与C++的区别：**Java中可以显示地将字段初始化。在C++中不能直接初始化类的实例字段。所有的字段必须在构造器中设置，且C++有一个特殊的初始化器列表语法。
>
> ```C++
> Employee::Employee(String n, double s, int y, int m, int d) : name(n), salary(s), hireDay(y, m, d)
> {
> }
> ```
>
> Java中没有这种必要，因为对象没有子对象，只有指向其他对象的指针。

#### 4.6.4 调用另一个构造器

this的两种用法：

- 指示一个方法的隐式参数
- `this(...)`这个构造器调用同一个类的另一个构造器。

```java
public Employee(double s){
  this("Employee #" + nextId, s); //Employee(double)构造器调用Employee(String, double)构造器
  nextId++;
}
```

> **与C++的区别：**Java中，this引用等价于C++中的this指针。但是，C++中一个构造器不能调用另一个构造器。

#### 4.6.5 初始化块

初始化数据字段的方法：

1. 在构造器中设置值
2. 在声明中赋值
3. 初始化块（首先运行初始化块，然后再运行构造器的主体部分），建议将初始化块放在字段定义之后。

**调用构造器的具体处理步骤：**

1. 如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器

2. 否则，

   a）所有数据字段初始化为其默认值（0，false，null）

   b）按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块

3. 执行构造器主体代码

#### 4.6.6 对象析构

​        C++中有显示的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码。在析构器中，最常见的操作是回收分配给对象的存储空间。由于Java会完成自动的垃圾回收，不需要人工回收内存，所以Java不支持析构器。

### 4.7 包

使用包的主要原因是确保类名的唯一性。

从编译器的角度来看，嵌套的包之间没有任何关系。每一个包都是独立的类集合。

> **与C++的区别：**C++中必须使用`#include`来加载外部特性的声明，因为除了正在编译的文件以及在头文件中明确包含的文件，C++编译器无法查看任何其他文件的内部。Java编译器则可以查看其他文件的内部，只要告诉他去哪里查看就可以了。Java中通过显示地给出类名，可以完全避免使用import机制；C++中则无法避免使用`#include`指令。

编译器在编译源文件的时候不检查目录结构。当包的路径出现错误，如果该源文件不依赖于其他包，就可以通过编译而不会出现编译错误。但是最终程序无法运行。包和目录不匹配，虚拟机找不到类。

标记为public的部分可以由任意类使用；标记为private的部分只能由定义它们的类使用。如果没有指定public或private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。

## 5. 继承

继承：基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，使新类能够适应新的情况。

反射（reflection）：程序运行期间更多地了解类及其属性的能力。

### 5.1 类、超类、子类

> **与C++的区别：**Java用关键字extends代替C++中的冒号（:）。Java中，所有的继承都是公共继承，而没有C++中的私有继承和保护继承。

关键字extends表明正在构造的新类派生于一个已存在的类。

已存在的类称为**超类**（superclass）、基类（base class）、父类（parent class）。

新类称为**子类**（subclass）、派生类（derived class）、孩子类（child class）。

使用**关键字super**调用被子类覆盖的父类方法，指示编译器调用超类方法的特殊关键字。

> **与C++的区别：**Java中使用关键字super调用超类的方法，而C++中则采用超类名加::操作符的形式。

子类构造器的第一条语句必须是super调用构造器的语句。如果子类的构造器没有显式地调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java编译器会报错。

> **注：**“this”的两个含义：1. 指示隐式参数的引用，2. 调用该类的其他构造器。
>
> ​	   “super”的两个含义：1. 调用超类的方法，2. 调用超类的构造器。
>
> ​       调用构造器的语句只能作为另一个构造器的第一条语句出现。构造器参数可以传递给当前类（this）的另一个构造器，也可以传递给超类（super）的构造器。

> **与C++的区别：**在C++构造器中，会使用初始化列表语法调用超类的构造器，而不调用super。
>
> ```java
> // C++
> Manager::Manager(String name, double salary, int year, int month, int day) : Employee(name, salary, year, month, day){
>   bonus = 0;
> }
> 
> // Java
> public Manager(String name, double salary, int year, int month, int day){
>   super(name, salary, year, month, day);
>   bonus = 0;
> }
> ```
>
> C++中一个类可以有多个超类。Java不支持多重继承。

**多态：**

**一个对象变量可以指示多种实际类型的现象称为多态。**在运行时能够自动地选择适当的方法，称为动态绑定。

> **与C++的区别：**C++中实现动态绑定，需要将成员函数声明为virtual。Java中，动态绑定是默认的行为，如果不希望让一个方法是虚拟的，可以将它标记为final。

- “is-a”规则，指出子类的每个对象也是超类的对象。另一种表述是*替换原则*，指出程序中出现超类对象的任何地方都可以使用子类对象替换。例如，可以将子类的对象赋给超类变量：

  ```java
  Employee e;
  e = new Employee();
  e = new Manager();
  ```

  Java中，对象变量是多态的。一个Employee类型的变量既可以引用一个Employee类型的对象，也可以引用Employee类的任何一个子类的对象。

**方法调用过程：**（以调用`x.f(args)`为例，x声明为类C的一个对象）

1. 编译器查看对象的声明类型和方法名。有可能存在多个名字为f但参数类型不一样的方法。此时，编译器已经知道所有可能被调用的候选方法。
2. 编译器确定方法调用中提供的参数类型。如果在所有名为f的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程是*重载解析*。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器就会报告一个错误。此时，编译器已经知道需要调用的方法的名字和参数类型。（返回类型不是签名的一部分，允许子类将覆盖方法的返回类型改为原返回类型的子类型）
3. 如果是private方法、static方法、final方法或者构造器，那么编译器可以准确地知道应该调用哪个方法。这称为*静态绑定*。如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用*动态绑定*。
4. 程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的时机类型对应的那个方法。假设x的实际类型时D，它是C类的子类。如果D类定义了方法`f(String)`，就会调用这个方法；否则，将在D类的超类中寻找`f(String)`，以此类推。
   - 每次调用方法都完成这个搜索，时间开销太大。因此，虚拟机预先为每个类计算了一个**方法表**，其中列出了所有方法的签名和要调用的实际方法。这样，调用方法时，虚拟机仅查找这个表就行了。

**注：**在覆盖一个方法时，子类方法不能低于超类方法的可见性。特别是，如果超类方法时public，子类方法必须也声明为public。

**final类**：不允许扩展的类，阻止继承。

**注：**对于final字段，构造对象之后就不允许改变它们的值了。如果将一个类声明为final，只有其中的方法自动地成为final，而不包括字段。

将方法或类声明为final的主要原因是：确保它们不会在子类中改变语义。

**强制类型转换：**



