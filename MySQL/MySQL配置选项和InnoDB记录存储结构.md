[TOC]

## 1. MySQL的客户端/服务端架构

**（类Unix系统）bin目录下启动MySQL服务器程序的可执行文件：**

- mysqld：MySQL服务器程序，运行这个可执行文件就可以直接启动一个MySQL服务器进程。但并不常用。

- mysqld_safe：一个启动脚本，间接调用mysqld并持续监视服务器的运行状态。当服务器进程出现错误，它可以帮助重启服务器程序。**使用mysqld_safe启动MySQL服务器程序，会将服务器程序的出错信息和其他诊断信息输出到错误日志。**

  > 出错日志默认写道一个以`.err`为扩展名的文件中，该文件位于MySQL的数据目录中。

- mysql.server：一个启动脚本，间接调用mysqld_safe。

- mysqld_multi：启动或停止多个服务器进程，也能报告它们的运行状态

- mysqld_safe、mysql.server和mysqld_multi本质上是一个Shell脚本

**bin目录下启动MySQL客户端程序的可执行文件：**

- mysql：通过这个可执行文件，可以与服务器程序交互，即发送请求并接收服务器的处理结果。

  ```
  // 启动mysql可执行文件的执行语句
  mysql -h主机名 -u用户名 -p密码
  ```

**客户端与服务器连接的过程：**

运行中的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到响应的过程本质上是一个进程间通信的过程。MySQL支持的客户端进程和服务器进程的通信方式有：**TCP/IP、命名管道和共享内存、UNIX域套接字**。

1. **TCP/IP**
   - MySQL采用TCP作为服务器和客户端之间的网络通信协议。
   - 在网络环境下，每台计算机都有一个唯一的IP地址，如果某个进程需要采用TCP协议进行网络通信，就可以向操作系统申请一个端口号。端口号是一个整数值，它的取值范围是0~65535。这样，网络中的其他进程就可以通过IP地址+端口号的方式与这个进程建立连接，这样进程之间就可以通过网络进行通信了。
   - MySQL服务器启动时会默认申请3306端口号。
2. **命名管道和共享内存**
   - Windows用户可以考虑在客户端进程和服务端进程之间使用命名管道或共享内存进行通信。
   - 使用共享内存进行通信的服务器进程和客户端进程必须位于同一台Windows主机中。
   - 命名管道和共享内存是Windows操作系统中的两种进程间通信方式。
3. **UNIX域套接字**
   - 服务器进程和客户端进程都运行在操作系统为类UNIX的同一台机器上，则可以使用UNIX域套接字进行进程间通信。

无论客户端进程和服务器进程采用哪种方式进行通信，最后实现的效果都是客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程返回一段文本（处理结果）。

**服务器处理客户端请求大致分为3部分：**

1. **连接管理**
   
   - 客户端可以采用TCP/IP、命名管道或共享内存、UNIX域套接字等几种方法与服务器进程建立连接。
   - 每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程专门处理与这个客户端的交互；**当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。** 避免频繁地创建和销毁线程，节省开销。
   - 客户端程序发起连接时，需要携带主机信息、用户名、密码等信息，服务器程序会对客户端程序提供的信息进行认证。
     - 如果认证失败，服务器程序会拒绝连接。
     - 如果客户端程序和服务端程序不运行在一台计算机上，可以通过采用传输层安全性（Transport Layer Security，TLS）协议对连接进行加密，从而保证数据传输的安全性。
   - **连接建立后**，与该客户端关联的服务端线程会一直等待客户端发送过来的请求。这个请求只是一个文本消息，还要经过各种处理。
   
2. **解析与优化**

   目前MySQL服务器已经获得文本形式的请求，接下来还需要经过各种处理。比较重要的是**查询缓存**、**语法解析**和**查询优化**。

   **查询缓存：**

   - MySQL服务器会把刚刚处理过的查询请求和结果缓存起来，如果下一次有同样的请求过来，直接从缓存中查找结果，不需要再去底层的表中查找。
   - 如果两个查询请求有任何字符上的不同（如，空格、注释、大小写），都会导致缓存不会命中。
   - 如果查询请求中包含某些系统函数、用户自定义变量和函数、系统表，如mysql、information_schema、performance_schema数据库中的表，则这个请求就不会被缓存。
   - MySQL的缓存系统会监测涉及的每张表，**只要该表的结构或者数据被修改，则与该表有关的所有查询缓存都将变为无效并从查询缓存中删除**。
   - 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销。MySQL8.0中直接将其删除。

   **语法解析：**

   - 如果查询缓存没有命中，就进入到正式的查询阶段了。
   - 客户端程序发送的请求是一段文本，MySQL服务器先对这段文本进行分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到MySQL服务器内部使用的一些数据结构上。

   **查询优化：**

   - 我们写的MySQL语句执行起来效率可能不是很高，MySQL优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等。
   - 优化的结果是生成一个执行计划。这个执行计划表明了应该要使用哪些索引执行查询，以及表之间的连接顺序是什么等等。
   
3. **存储引擎**

   - MySQL服务器把数据的存储和提取操作都封装到一个名为存储引擎的模块中。
   - 逻辑上，表是由一行一行的记录组成的。但在物理上如何记录，怎么从表中读取数据，以及怎么把数据写入具体的物理存储器上，都是存储引擎负责的事情。
   - MySQL提供了各种各样的存储引擎，不同的存储引擎管理的表可能有不同的存储结构，采用的存取算法也可能不同。
   - 从MySQL5.5.5开始**默认存储引擎是InnoDB**,之前版本的默认引擎是MyISAM.

   为了管理方便，把MySQL服务器处理请求的过程分为**server层**和**存储引擎层**。

   - server层：包括连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存取的功能。
   - 存储引擎层：存储真实数据的功能。
   - server层和存储引擎层交互是以**记录**为单位的。以SELECT为例，server层根据执行计划先向存储引擎层取一条记录，然后判断是否符合WHERE条件；如果符合，就发送给客户端，否则跳过该记录，然后继续向存储引擎索要下一条记录。

## 2. 启动选项和系统变量

### 2.1 启动选项

1. **命令行上使用选项：**

   - 启动服务器程序时，禁止各客户端使用`TCP/IP`网络进行通信。启动客户端程序时，在`-h`参数后面紧跟服务器的IP地址，就意味着客户端要求和服务器之间通过`TCP/IP`网络进行通信

     ```mysql
     mysql --skip-networking
     mysql --skip_networking  # 两种写法等价
     
     mysql -h127.0.0.1 -uroot -p
     Enter password:
     # ERROR 2003 (HY000): Can't connect to MySQL server on '127.0.0.1' (10061)
     # 连接失败意味着之前在启动服务器时指定的启动选项--skip_networking生效了
     ```

     

   - 启动服务器程序时，更改表的默认存储引擎（默认使用InnoDB作为表的存储引擎）。

     ```mysql
     mysqld --default-storage-engine=MyISAM
     ```

2. **配置文件中使用选项：**

   把需要设置的启动选项写在配置文件中，每次启动服务器时都从这个文件中加载相应的启动选项。配置文件使用`.ini`或`.cnf`扩展名。

**注意：** 如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准。

### 2.2 系统变量

系统变量：MySQL服务端程序在运行过程中用到的影响程序行为的变量。

- `max_connections`：允许同时连入的客户端数量
- `default_storage_engine`：表的默认存储引擎
- `query_cache_size`：查询缓存的大小

**查看系统变量：**

​	系统变量非常多，用LIKE表达式指定过滤条件，可以用%模糊查询。

```mysql
mysql> SHOW VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set, 1 warning (0.08 sec)

mysql> SHOW VARIABLES LIKE 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 200   |
+-----------------+-------+
1 row in set, 1 warning (0.00 sec)
```

> MySQL服务器实际上允许`max_connections+1`个客户端连接，额外的一个是给超级用户准备的。

按**作用范围**，可将系统变量分为GLOBAL（全局范围）和SESSION（会话范围）。

- **GLOBAL（全局范围）**：影响服务器的整体操作，全面变量。
- **SESSION（会话范围）**：影响某个客户端连接的操作，会话变量。

服务器在启动时，会将每个全局变量初始化为其默认值（可以通过命令行或配置文件中指定的选项更改这些默认值）。服务器还为每个连接的客户端维护一组会话变量，客户端的会话变量在连接时使用相应全局变量的当前值进行初始化。

- 以`default_storage_engine`为例，服务器启动时会初始化一个名为`default_storage_engine`、作用范围时GLOBAL的系统变量。每当有一个客户端连接到该服务器时，服务器都会单独为该客户端分配一个名为`default_storage_engine`、作用范围是SESSION的系统变量，作用范围是SESSION的系统变量值按照当前当前作用范围是GLOBAL的同名系统变量值进行初始化。

在服务端程序运行期间通过客户端程序设置系统变量的语法：

```mysql
SET [GLOBAL|SESSION] 系统变量名 = 值;
SET [@@(GLOBAL|SESSION).]系统变量名 = 值;
#之后新连接到服务器的客户端都用MyISAM作为默认存储引擎
SET GLOBAL default_storage_engine=MyISAM;
SET @@GLOBAL.default_storage_engine=MyISAM;
#只对本客户端生效
SET SESSION default_storage_engine=MyISAM;
SET @@SESSION.default_storage_engine=MyISAM;
SET default_storage_engine=MyISAM;
```

**注意**：在设置系统变量的语句中省略作用范围，默认作用范围是SESSION。

**查看和设置不同作用范围下的系统变量：**

- 把SESSION作用范围的系统变量值设置为MyISAM，GLOBAL作用范围的值并没有改变。
- 如果某个客户端改变了某个系统变量在GLOBAL作用范围的值，并不会影响该系统变量在当前已经连接的客户端作用范围为SESSION的值，只会影响后续连入的客户端作用范围为SESSION的值。

```mysql
mysql> SET GLOBAL default_storage_engine=MyISAM;
Query OK, 0 rows affected (0.00 sec)

mysql> SHOW GLOBAL VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set, 1 warning (0.01 sec)

mysql> SHOW SESSION VARIABLES LIKE 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | InnoDB |
+------------------------+--------+
1 row in set, 1 warning (0.00 sec)
```

> **Tips：**
>
> - 并不是所有的系统变量都具有GLOBAL和SESSION的作用范围。
>   - `max_connections`表示服务器程序支持同时最多有多少个客户端程序进行连接，**只具有GLOBAL作用范围**。
>   - `insert_id`表示在对某个包含AUTO_INCREMENT列的表进行插入时，该列初始的值，**只具有SESSION作用范围**。
> - 有些系统变量是只读的，并不能设置值。如`version`。

**启动选项和系统变量的区别：**

- 启动选项是程序启动时由用户传递的一些参数，系统变量是影响服务器程序运行行为的变量。
- 大部分的系统变量都可以作为启动选项传入。
- 有些系统变量是在程序运行过程中自动生成的，不可以当做启动选项来设置，如`character_set_client`表示客户端请求数据的字符集。
- 有些启动选项也不是系统变量，如`default-file`表示配置路径。

### 2.3 状态变量

状态变量：关于程序运行状态的变量。

- `Threads_connected`：表示当前有多少客户端与服务器建立了连接。
- 因为状态变量是用来显示服务器程序运行状态的，所以状态变量的值只能由服务器程序自己设置，不能人为设置。
- 有GLOBAL和SESSION两个作用范围。

### 2.4 总结

1. 启动选项可以**调整服务器启动后的一些行为**。
2. 系统变量是服务器程序中维护的一些变量，这些变量**影响着服务器的行为**。
3. 状态变量是用来**显示服务器程序运行状态的**。

## 3. 字符集和比较规则

**一些重要的字符集**：

- ASCII字符集：共收录128个字符，用**一个字节**来进行编码
- ISO 8859-1字符集：共收录256个字符，在ASCII字符集的基础上又扩充了128个西欧常用字符（包括德法两国的字母），用**一个字节**来进行编码
- GB2312字符集：收录了汉字已经拉丁字母、希腊字母、日文平假名及平假名字母、俄语西里尔字母，同时兼容ASCII字符集。如果该字符在ASCII字符集中，则采用一字节编码；否则采用两字节编码。
- GBK字符集：在收录的字符范围上对GB2312字符集进行了扩充，编码方式兼容GB2312。
- UTF-8字符集：几乎收录了当今世界各个国家、地区使用的字符，还在不断地扩充。兼容ASCII字符集，采用变长编码方式，编码一个字符时需要使用1~4个字节。但一些常用的字符用1~3字节就可以表示了，而且**在MySQL中字符集表示一个字符所用的最大字节长度在某些方面会影响系统的存储和性能**。所以在MySQL中又分出下面两种字符集：
  - utf8mb3：只使用1~3字节表示字符。utf8是utf8mb3的别名。
  - utf8mb4：使用1~4字节表示字符。MySQL8.0中，已设为默认字符集。

**比较规则：**

- 每种字符集对应若干种比较规则，且每种字符集都有一种默认的比较规则。
- utf8字符集默认的比较规则是`utf8_general_ci`，通用的比较规则，不区分大小写。

**MySQL有4个级别的字符集和比较规则，分别是：**

- 服务器级别
- 数据库级别
- 表级别
- 列级别

**服务器级别：**

- MySQL提供了两个系统变量来表示服务器级别的字符集和比较规则。
- 在启动服务器程序时，可通过**启动选项**或者在服务器程序**运行过程中使用`SET`语句**来改变这两个系统变量的值。

|       系统变量       |         描述         |
| :------------------: | :------------------: |
| character_set_server |  服务器级别的字符集  |
|   collation_server   | 服务器级别的比较规则 |

**数据库级别：**

- **创建**和**修改**数据库时可以指定该数据库的字符集和比较规则。
- 查看当前数据库使用的字符集和比较规则，需要先**使用`USE`语句选择当前的默认数据库**；如果没有默认数据库，则变量与服务器级别下相应的系统变量具有相同的值。
- `character_set_database`和`collation_database`只是用来告诉用户当前数据库的字符集和比较规则是什么，**不能通过修改这两个变量的值来改变当前数据库的字符集和比较规则**。
- 创建数据库时，如果不指定字符集和比较规则，那么将使用服务器级别的字符集和比较规则作为数据库的字符集和比较规则。

|        系统变量        |         描述         |
| :--------------------: | :------------------: |
| character_set_database |  当前数据库的字符集  |
|   collation_database   | 当前数据库的比较规则 |

**表级别：**

- **创建**和**修改**表的时候指定表的字符集和比较规则。
- 创建表时，如果没有指明字符集和比较规则，则使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则。

**列级别：**

- 对于**存储字符串**的列，同一个表中不同的列也可以有不同的字符集和比较规则。
- **创建**和**修改**列的时候可以指定该列的字符集和比较规则。
- 对于某列来说，如果在创建和修改表的语句中没有指明字符集和比较规则，则使用该列所在的表的字符集和比较规则作为其字符集和比较规则。
- 如果列中存储的数据不能用修改后的字符集进行表示，则会发生错误。

## 4. InnoDB记录存储结构

### 4.1 InnoDB页

InnoDB将表中的数据存储到磁盘上，即使关闭并重启服务器，数据仍然存在。**真正处理数据的过程发生在内存中**，所以需要把磁盘中的数据加载到内存中；如果是处理写入或修改请求，还需要把内存中的内容刷新到磁盘中。

**问题**：读写磁盘比读写内存在速度上差了好几个数量级，InnoDB是如何处理的呢？

**回答**：InnoDB将数据划分成若干页，以**页**作为磁盘和内存之间交互的基本单位。页的大小一般为16KB，即一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

> 系统变量`innodb_page_size`表明了InnoDB存储引擎中的页大小，默认值为16384B，即16KB。该变量只能在第一次初始化MySQL数据目录时指定，在服务器运行过程中不可以改变页面大小。

```mysql
CREATE TABLE 表名 (列信息) ROW_FORMAT=行格式名称;
ALTER TABLE 表名 ROW_FORMAT=行格式名称;
```

### 4.2 InnoDB行格式

InnoDB有4种不同的行格式：COMPACT、REDUNDANT、DYNAMIC、COMPRESSED。

#### COMPACT行格式

一条完整的记录分为**记录的额外信息**和**记录的真实数据**。

额外信息包括：变长字段长度列表、NULL值列表、记录头信息。

**变长字段长度列表**：

- **变长字段**占用的存储空间分为两部分：真正的数据部分、该数据占用的字节数。
- 变长字段长度列表存储各变长字段的**真实数据占用的字节数**按照列的顺序**逆序存放**。
- 变长字段长度列表只存值为**非NULL**的列的内容长度，不存储值为NULL的列的内容长度。
- 并不是所有的记录都有变长字段长度列表这部分，如果表中所有的列都不是变长的数据类型或所有列的值都是NULL，就不需要这部分。

InnoDB在读取记录的变长字段长度列表时，先查看表结构，确定用1字节还是2字节来表示一个变长字段的真实数据占用的字节数。W个字节表示一个字符，变长类型VERCHAR(M)最多能存储M个字符，该类型表示的字符串最多占用的字节数是W x M。该变长字段实际存储的字符串占用的字节数是L。

- M x W <= 255，使用1字节来表示真实数据占用的字节数。
- M x W > 255，
  - L <= 127，用1字节来表示真实数据占用的字节数
  - L > 127，用2字节表示真实数据占用的字节数

**NULL值列表**：

如果把列中为NULL的值都放到记录的真实数据中存储，会占用许多不必要的空间。**COMPACT把一条记录中值为NULL的列统一存储到NULL值列表中。**

处理过程：

- 首先统计表中允许存储NULL的列有哪些
- 如果表中没有允许存储NULL的列，则NULL值列表就不存在了。否则，将每个允许存储NULL的值对应**一个二进制位**，二进制位按照列的顺序**逆序排列**。
  - 二进制位值为1，表示该列的值为NULL
  - 二进制位值为0，表示该列的值不为NULL
- MySQL规定NULL值列表必须用**整数个字节的位**表示，如果使用的二进制位个数不是整数个字节，则**在字节的高位补0**。

**记录头信息**：

- 由固定的5字节组成，用于描述记录的一些属性。

**真实数据：**

- 自定义为列的数据 + **隐藏列**
- 隐藏列：
  - `row_id` 行ID
  - `trx_id` 事务ID
  - `roll_pointer` 回滚指针
- InnoDB为每条记录都添加trx_id和roll_pointer，但row_id是可选的。只有在**没有自定义主键**以及**没有不允许存储NULL值的UNIQUE键**的情况下，才会添加该列。这种设计是由InnoDB表的主键生成策略决定的。
- **InnoDB表的主键生成策略**：
  - 优先使用用户自定义的主键作为主键
  - 如果用户没有自定义主键，则选取一个不允许存储NULL值的UNIQUE键作为主键
  - 如果表中没有不允许存储NULL值的UNIQUE键，则InnoDB会为表默认添加row_id的隐藏列作为主键

> **注意**：
>
> 1. 对于CHAR(M)类型，如果采用变长编码的字符集，则该列的值占用的字节数也会被存储到变长字段长度列表中。如果采用定长编码字符集，则不会。
> 2. 采用变长编码字符集的CHAR(M)类型的列要求**至少占用M个字节**。
>    - 如使用utf8字符集，类型为CHAR(10)的列来说，该列存储的数据占用字节长度的范围在10~30字节。即使向该列存储一个空字符串也会占用10字节，**目的是希望以后更新该列时，在新值的字节长度大于旧值设为字节长度但不大于10字节时，可以在该记录处直接更新。**而不是在存储空间中再重新分配一个新的记录空间，导致原有的记录空间称为**碎片**。

#### REDUNDANT行格式

MySQL5.0之前使用的行格式，与COMPACT的区别：

- 记录的额外信息只包括**字段长度偏移列表**和**记录头信息**
- 记录该条记录中所有列（包括隐藏列）的长度信息，按照逆序存储
- 采用两个相邻偏移量的差值来计算各个列值的长度，即长度是累计的
- 记录头信息占用6字节
- 在长度偏移列表中，将列对应的偏移量值的第一个比特位作为是否为NULL的依据

#### 溢出列

一个页的大小一般是16KB，即16384字节，当要存储的列中的实际数据大于页大小时，需要将一部分数据存储到别的页，这些页就是**溢出页**。

COMPACT和REDUNDANT行格式中，对于占用存储空间非常多的列，**在记录的真实数据处只会存储该列的一部分数据，而把剩余的数据分散存储到几个其他的页中，然后在记录的真实数据处用20字节存储指向这些页的地址。这些页使用链表进行连接。**

**产生溢出页的临界点**

- MySQL规定一个页中至少存放两条记录，页中需要存储132字节的额外信息，每条记录需要存储27字节的额外信息，假设一个列的真实数据占用的字节数为n，如果该列不发生溢出现象，需要满足`132+2x(27+n) < 16384`。
- 解得`n < 8099`，这是对于只有一个列的表来说的。
- 当表有多列时，如果一条记录的某个列存储的数据占用的字节数非常多时，该列就可能称为溢出列。

#### DYNAMIC和COMPRESSED行格式

和COMPACT行格式相似，但在处理溢出列的数据时有点区别：

- 它们不会在记录的真实数据处存储该溢出列的真实数据，而是**把该列的所有真实数据都存储到溢出页中**，只在记录的真实数据处存储20字节大小的指向溢出页的地址，这20字节中还包括真实数据占用的字节数。

**COMPRESSED行格式和DYNAMIC行格式的区别：**

- COMPRESSED行格式会采用压缩算法对页面进行压缩。

