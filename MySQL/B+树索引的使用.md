# B+树索引的使用

- 每个索引对应一个B+树。所有的用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。
- InnoDB存储引擎会自动为主键创建索引（如果没有显示指定主键或者没有声明不允许存储NULL的UNIQUE键，会自动添加主键），聚簇索引中包含的是完整的用户记录。
- 二级索引的叶子节点包含的用户记录由索引列+主键组成。如果通过二级索引查找完整的用户记录，需要执行回表操作，也就是通过二级索引找到主键之后，再到聚簇索引中查找完整的用户记录。
- B+树中的每层节点都按照索引列的值从小到大的顺序排序组成了双向链表，而且每个页内的记录都按照索引列的值从小到大的顺序形成了一个单向链表。如果是联合索引，则页面和记录先按照索引列中前面的列的值排序；如果该列的值相同，再按照索引列中后面的列的值排序。
- 通过索引查找记录时，是从B+树的根节点开始一层一层向下搜索的。由于每个页面中的记录都划分成了若干组，每个组中索引列值最大的记录在页内的偏移量会被当作槽依次存放在页目录中，因此可以在页目录中通过二分法快速定位到索引列等于某个值的记录。

## 索引的代价

- 空间上的代价

  每创建一个索引，都要为它建立一棵B+树。每一棵B+树的每一个节点都是一个数据页，一个数据页默认会占用16KB的存储空间，而一棵很大的B+树由许多数据页组成，这会占用很大的存储空间。

- 时间上的代价

  每当对表中的数据进行增删改查操作时，都需要修改各个B+树索引。B+树中的每层节点都按照索引列的值从小到大的顺序排列组成了双向链表。节点中的记录都按照索引列的值从小到大的顺序形成了单向链表。而增删改查操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行页面分裂、页面回收等操作，以维护节点和记录的排序。

  在执行查询语句前，首先要生成一个执行计划。一般情况下，一条查询语句在执行过程中最多使用一个二级索引，在生成执行计划时需要计算使用不同索引执行查询时所需的成本，最后选取成本最低的那个索引执行查询。如果建立了太多索引，可能会导致成本分析过程耗时太多，从而影响查询语句的执行性能。

## 应用B+树索引

在使用某个索引执行查询时，关键的问题就是通过搜索条件找出合适的扫描区间，然后再到对应的B+树中扫描索引列值在这些扫描区间的记录。

对于每个扫描区间来说，仅需要通过B+树定位到该扫描区间中的第一条记录，然后就可以沿着记录所在的单向链表向后扫描，直到某条记录不符合形成该扫描区间的边界条件为止。

对于B+树索引来说，索引列和常数使用=、IN、NOT IN、IS NULL、IS NOT NULL、>、<、>=、<=、BETWEEN、!=、LIKE连接起来，就可以产生所谓的扫描区间。但要注意：

- IN的语义跟若干个等值匹配操作符（=）之间用OR连接起来的语义是一样的，都会产生多个单点扫描区间。

- !=产生的扫描区间：

  - ```sql
    SELECT * FROM table1 WHERE key1 != 'a';
    ```

  - 使用key1上的索引执行查询时，对应的扫描区间是(-∞,'a')和('a',∞)

- LIKE操作符只有在匹配完整的字符串或者匹配字符串前缀时才产生合适的扫描区间。对于某个索引列来说，字符串前缀相同的记录在由记录组成的单向链表中肯定是相邻的，因为比较字符串的大小其实就是依次比较每个字符的大小。

### 索引用于排序

使用ORDER BY自居对查询出来的记录按照某种规则进行排序时，一般情况下 ，我们只能把记录加载到内存中，然后再用一些排序算法在内存中对这些记录进行排序。有时查询的结果集太大导致无法在内存中进行排序，此时需要暂时借助磁盘空间来存放中间结果，在排序操作完成后再把排好序的结果集返回客户端。

**文件排序**是指MySQL中在内存或者磁盘中进行排序的方式，但是**如果ORDER BY子句中使用了索引列，就有可能省去在内存或者磁盘中排序的步骤**。

注意事项：

- 在使用联合索引时，ORDER BY子句后面的列的顺序必须按照索引列顺序给出。

- 仅包含联合索引的索引列中左边连续的列进行排序时，也可以使用B+树索引。

- 当联合索引的索引列左边连续的列为常量时，也可以使用联合索引对右边的列进行排序

  - 如，联合索引index(key_part1, key_part2, key_part3)，在执行下面这个查询时，可以使用B+树索引

  - ```sql
    SELECT * FROM table1 WHERE key_part1 = 'a' AND key_part2 = 'b' ORDER BY key_part3 LIMIT 10;
    ```

**不可以使用索引进行排序的几种情况：**

- ASC、DESC混用。对于使用联合索引的场景，我们要求各个排序列的排序规则是一致的。
- 排序列包含非同一个索引的列。
- 排序列是某个联合索引的索引列，但是这些排序列在联合索引中并不连续。
- 用来形成扫描区间的索引列与排序列不同。
- 排序列不是以单独列名的形式出现在ORDER BY子句中。

### 索引用于分组

与使用B+树索引进行排序差不多，分组列的顺序也需要与索引列的顺序一致。

## 回表的代价

需要执行回表操作的记录越多，使用耳机索引进行查询的性能就越低。

存在全表扫描比使用索引更优越的情况，比如扫描区间是key1的值在'a'~'c'之间，但key1的值在'a'~'c'之间的记录数大约占了99%以上，如果使用索引，则会有99%以上的记录需要执行回表操作，还不如使用全表扫描。

**查询优化器**会事先针对表中的记录计算一些统计数据，然后利用这些统计数据或者访问表中的少量记录来计算需要执行回表操作的记录数。如果需要执行回表操作的记录数越多，就越倾向于全表扫描，反之更倾向于二级索引+回表的方式。

一般情况下，可以给查询语句指定LIMIT子句来限制查询返回的记录数，这可能会让查询优化器倾向于选择耳机索引+回表的方式进行查询，原因是回表的记录越少，性能提升就越高。

## 更好地创建和使用索引

- **只为用于搜索、排序、分组的列创建索引。**仅出现在查询列表中的列就没必要建立索引了。（无需为SELECT后面的列创建索引，WHERE、ORDER BY、GROUP BY子句后面的列可以创建索引）
- **考虑索引列中不重复值的个数。**在通过二级索引+回表的方式执行查询时，某个扫描区间中包含的二级索引记录数量越多，就会导致回表操作的代价越大。在为某个列创建索引时，需要考虑该列中不重复值的个数占全部记录条数的比例，如果比例太低，说明该列包含过多的重复值，在通过二级索引+回表的方式执行查询时，就可能执行太多次回表操作。
- **索引列的类型尽量小。**数据类型（该类型占用的存储空间）越小，索引占用的存储空间就越少，在一个数据页内就可以存放更多的记录，磁盘I/O带来的性能损耗就越小。一次页面I/O可以将更多的记录加载到内存中，读写效率也就更高。
- **为列前缀建立索引。**为字符串类型的列创建索引时，字符串越长，在索引中占用的存储空间就越大。
