# InnoDB 数据页结构

页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。

## 数据页结构

16KB的数据页被划分为7个部分，有的占用固定大小的字节数，有的不确定：

- File Header：文件头部，**38byte**，存放页的通用信息
- Page Header：页面头部，**56byte**，存放数据页专有的信息
- Infimum+Supremum：页面中的最小记录和最大记录，**26byte**，两个虚拟的记录
- User Records：用户记录，**不确定**，用户存储的记录内容
- Free Space：空闲空间，**不确定**，页中尚未使用的空间
- Page Directory：页目录，**不确定**，存放页中某些记录的相对位置
- File Trailer：文件尾部，**8byte**，校验页是否完整

## 记录在页中的存储

存储的记录会按照指定的行格式存储到User Records部分。

且在一开始生成页时，并没有User Records部分，每插入一条记录，会从Free Space部分申请一个记录大小的空间，并将这个空间划分到User Records部分。

当Free Space部分的空间全部被User Records替代，就意味着这个页使用完了。如果再有新的记录插入，需要申请新的页了。

### 行格式中的记录头信息

- deleted_flag：标记当前记录是否被删除，占用1bit。0表示记录没有被删除，1表示记录已经被删除。
  - 被删除的记录不从磁盘上移除的原因：移除他们之后，还需要**在磁盘上重新排列其他的记录**，这会带来性能消耗。所以用一个删除标记可以避免这个问题。
  - 所有被删掉的记录会组成一个**垃圾链表**，记录在这个链表中的空间称为可重用空间。之后有新纪录插入到表中，就有可能覆盖掉被删除的这些记录所占用的存储空间。
- min_rec_flag：B+树每层非叶子节点中的最小的记录项会添加该标记。
- heap_no：向表中插入的记录本质上都是放到了数据页的User Records部分，这些记录都一条条亲密无间地排列在一起。这种一条条记录亲密无间排列在一起的结构称为**堆**。heap_no表示一条记录在堆中的相对位置。
  - 每新申请一条记录的存储空间时，该条记录比物理位置在它前面的那条记录的heap_no值大1。
  - 属性值从2开始。
  - 0和1是记录页面中的最小记录和页面中的最大记录的两条**虚拟记录**（并非用户添加，是InnoDB自动添加的）。所以他们在堆中的相对位置最靠前。
  - **比较记录的大小就是比较主键的大小。**
  - InnoDB**规定**：任何用户记录都比Infimum记录大，任何用户记录都比Supremum小。
  - 堆中记录的heap_no在分配之后就不会再发生改动了，即使之后删除堆中的某条记录，这条被删除记录的heap_no值也依然保持不变。
- record_type：表示当前记录的类型。共4种，0表示普通记录，1表示B+树非叶子节点的目录项记录，2表示Infimum记录，3表示Supremum记录。自己插入的记录就是普通记录。
- next_record：表示从当前记录的真实数据到**下一条记录的真实数据的距离**。（记录按照主键从小到大的顺序形成一个单向链表）
  - 值为正数，说明当前记录的下一条记录在当前记录的后面。
  - 值为负数，说明当前记录的下一条记录在当前记录的前面。
  - 比如，第1条记录的next_record=32，意味着从第1条数据的地址处向后找32字节便是下一条记录的真实数据。
  - 下一条记录指的是按照主键由小到大的顺序排列的下一条记录，而不是插入顺序中的下一条记录。
  - **规定**Infimum记录的下一条记录就是本页中主键值最小的用户记录，本页中主键值最大的用户记录的下一条记录是Supremum记录。Supremum记录的next_record值为0，是单向链表的最后一个节点。

**删除一条记录后，发送的变化：**（以第2条记录为例，共4条记录）

- 第2条记录并没有从存储空间中移除，而是把该条记录的deleted_flag值设置为1；
- 第2条记录的next_record值变为0，意味着该记录后面没有记录了；
- 第1条记录的next_record指向了第3条记录；
- Supremum记录的n_owned值从5变成了4。

**当再次插入这条记录时：**

- InnoDB没有为新纪录的插入而申请新的存储空间，而是直接复用了原来被删除记录的存储空间。

**总结：无论对页内的记录进行多少次的增删改查，InnoDB始终会维护记录的一个单向链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。**当数据页中存在多条被删除的记录时，使用这些记录的next_record属性将这些被删除的记录组成一个垃圾链表，以备之后重用这部分存储空间。

Q：为什么next_record指针要指向记录头信息和真实数据之间的位置，而不是直接指向整条记录开头的位置？

A：这个位置向左读取是记录头信息，向右读取是真实数据。且变长字段长度列表、NULL值列表中的信息都是逆序存放的，这样可以使得记录中为位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。

## Page Directory（页目录）

当我们需要根据主键值查找页中的某条记录时，可以从Infimum记录开始，沿着单向列表向后查找。遍历查找在数据量小的时候没什么问题，但当数据量大时，遍历查找会损失性能。

**目录的制作过程：**

1. 将所有正常的记录（包括Infimum和Supremum记录，但不包括已经移除到垃圾链表的记录）划分为几个组。
2. 每个组的最后一条记录（即组内最大的那条记录）相当于“带头大哥”，组内其余的记录相当于“小弟”。“带头大哥”记录的头信息中的n_owned属性表示该组内公有几条记录。
3. 将每个组中最后一条记录在页面中的地址偏移量（该记录的真实数据与页面中第0个字节之间的距离）单独提取出来，按顺序存储到靠近页尾部的地方。这个地方就是**Page Directory**。页目录中的这些地址偏移量称为槽，每个槽占用2字节。页目录由多个槽组成。
   - 每个槽占用2字节，按照对应记录的大小相邻分布。槽对应的记录越小，它的位置越靠近File Trailer。

**设计InnoDB的大叔对每个分组中的记录条数是有规定的：**

- Infimum记录所在的分组只能有1条记录
- Supremum记录所在的分组拥有的记录条数只能在1~8之间
- 剩下的分组中的记录的条数范围只能在4~8条之间

**记录分组的步骤：**

1. 初始情况下，一个数据页中只有Infimum记录和Supremum记录，它们分别属于两个分组。页目录中也只有两个槽，分别代表Infimum记录和Supremum记录在页面中的地址偏移量。
2. 之后每插入一条记录，都会从页记录中找到对应记录的主键值比待插入记录的主键值大并且差值最小的槽，然后把槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组内的记录数等于8.
3. 当一个组中的记录数等于8后，再插入一条记录，**会将组中的记录拆分成两个组**，其中一个组中4条记录，另一个5条记录。拆分的过程会在页目录中新增一个槽，记录这个新增分组中最大的那条记录的偏移量。

**在一个数据页中查找指定主键值的记录的步骤：**

1. 通过**二分法**确定该记录所在分组对应的槽，然后找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的next_record属性遍历该槽所在的组中的各个记录。（因为一个组中的记录数最多是8，所以组内顺序遍历代价很小）

## Page Header（页面头部）

页结构的第2部分，占用56字节，**存储**在数据页中的**记录的状态信息**，如数据页中已存储多少条记录、Free Space在页面中的地址偏移量、页目录中存储了多少个槽等。

- PAGE_DIRECTION：表示最后一条记录插入的方向。如果新插入的一条记录的主键值比上一条记录的主键值大，则这条记录的插入方向是右边，反之为左边。
- PAGE_N_DIRECTION：记录连续插入的方向一致的记录的条数。如果最后一条记录的插入方向改变，这个状态值被清零后重新统计。

## File Header（文件头部）

页结构的第1个组成部分，占用38字节，描述了一些通用于各种页的信息，比如页的编号、上一页和下一页是谁等。

- FIL_PAGE_OFFSET：页号，每个页都有一个单独的页号，InnoDB通过页号来唯一定位一个页。
- FIL_PAGE_TYPE：表示当前页的类型。
  - FIL_PAGE_INDEX：索引页
- FIL_PAGE_PREV和FIL_PAGE_NEXT：分别表示本数据页的上一页和下一页的页号，InnoDB无法一次性为这么多数据分配一个非常大的存储空间，而如果分散到多个不连续的页中进行存储，则需要把这些页关联起来。

## File Trailer（文件尾部）

为了检测一个页是否完整，在每个页的尾部加了File Trailer部分。由8个字节组成，可分成2个小部分。

如果页中的数据在内存中被修改了，那么在修改后的某个时间还需要把数据刷新到磁盘中。File Trailer就是防止在刷新时只刷新了一部分数据的情况发生。

- 前4字节代表页的校验和。这部分与File Header中的校验和相对应，每当一个页面在内存中发生修改时，在刷新之前就要把页面的校验和算出来。因为File Header在页的前面，所以File Header中的校验和会被首先刷新到磁盘，当完全写完后，校验和也会被写到页的尾部。
  - 如果页面刷新成功，页首和页尾的校验和应该是一致的。
  - 如果刷新了一部分之后断电了，那么File Header中的校验和代表已经修改过的页，而File Trailer中的校验和代表原先的页，两者不同意味着刷新期间发生了错误。
- 后4个字节代表页面被最后修改时对应的LSN的后4字节，正常情况下应该与File Header部分的FIL_PAGE_LSN的后4字节相同。



